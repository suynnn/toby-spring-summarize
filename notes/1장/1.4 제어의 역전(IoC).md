## 1.4 제어의 역전(IoC)

### 1.4.1 오브젝트 팩토리

UserDaoTest 처음 목적 : UserDao 기능이 잘 동작하는지 테스트. 그런데 지금 어떤 구현 클래스를 사용할지 결정하는 또 다른 책임까지 떠맡고 있음

-   UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 그렇게 만들어진 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계 맺어주는 것으로 각각의 기능 분리

#### 팩토리 factory

\- 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트 돌려주는 오브젝트

\- 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적

#### 설계도로서의 팩토리

오브젝트들의 역할과 관계 분석 및 정리

-   UserDao : 핵심 데이터 로직
-   ConnectionMaker : 핵심 기술 로직
-   DaoFactory : 이런 애플리케이션들의 오브젝트들을 구성하고 그 관계를 정의

실질적인 로직 담당 컴포넌트 : USerDao, ConnectionMaker

애플리케이션 구성하는 **컴포넌트 구조**와 관계 정의한 **설계도 역할** : DaoFactory

\- 새로운 ConnectionMaker 구현 클래스로 변경이 필요하다면 DaoFactory를 수정해서 변경된 클래스를 생성해 설정해주도록 코드 수정하면 됨

\- 여전히 UserDao는 변경 필요 없음. 동시에 DB 연결 방식은 자유로운 확장 가능

결론 : **애플리케이션 컴포넌트 역할**을 하는 오브젝트와 **애플리케이션 구조를 결정**하는 오브젝트를 분리했다는 데 의의

### 1.4.2 오브젝트 팩토리의 활용

다른 DAO 생성 기능이 생겼을 때의 문제점

-   UserDao 생성하는 userDao() 메서드 복사해서 accountDao(), messageDao() 메서드로 만든다면?
-   ConnectionMaker 구현 클래스의 오브젝트 생성 코드가 메서드마다 반복하게 됨

```
return new UserDao(new DConnectionMaker()); 

return new AccountDao(new DConnectionMaker());

return new MessageDao(new DConnectionMaker()); // 파라미터 안 ConnectionMaker 구현 클래스 생성 코드가 반복됨
```

\-> 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능이 중복돼서 나타남

DAO가 더 많아지면 ConnectionMaker의 구현 클래스를 바꿀 때마다 모든 메서드를 일일이 수정해야 함

\- 중복 문제 해결법 : 분리

-   ConnectionMaker의 구현 클래스를 결정하고 오브젝트 만드는 코드를 별도의 메서드로 뽑아내기

### 1.4.3 제어권의 이전을 통한 제어관계 역전

제어 역전이란? 프로그램의 제어 흐름 구조가 뒤바뀌는 것

-   일반적으로 프로그램 흐름은 main() 메서드 같이 프로그램 시작점에서 다음에 사용할 오브젝트를 결정하고 이를 생성하고 만들어진 오브젝트에 있는 메서드 호출, 또 다음 사용할 거 결정하고 호출하는 식의 작업이 반복됨
    -   각 오브젝트는 프로그램 흐름 결정할 때나 사용할 오브젝트 구성 작업에 능동적으로 참여

\-> 모든 종류의 작업을 **사용하는 쪽에서 제어하는 구조**

제어 역전이란? **이런 제어 흐름의 개념을 거꾸로 뒤집는 것**

-   오브젝트가 자신이 사용할 오브젝트 스스로 선택 및 생성 안함 -> 모든 오브젝트는 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어짐
-   **모든 제어 권한을 자신이 아닌 다른 대상에게 위임함**
-   ex) 서블릿 - 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스 오브젝트 만들고 그 안의 메서드 호출

프레임워크도 제어의 역전 개념이 적용된 기술

-   라이브러리 : 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름 직접 제어
-   프레임워크 : 애플리케이션 코드가 프레임워크에 의해 사용됨
    -   **분명한 제어의 역전 개념이 적용**되어 있어야 프레임워크라 부를 수 있음
    -   애플리케이션 코드는 프레임워크가 짠 틀에서 수동적으로 동작해야 함

UserDao와 DaoFactory에도 적용됨

-   자신이 어떤 ConnectionMaker 구현 클래스를 만들고 사용할지 결정할 권한을 DaoFactory에 넘겨서 UserDao는 능동적이 아닌 수동적 존재가 되었음
-   UserDaoTest는 DaoFactory가 만들고 초기화해서 자신에게 사용하도록 공급해주는 ConnectionMaker를 사용할 수 밖에 없음
-   UserDao와 ConnectionMaker의 구현체 생성 책임도 DaoFactory가 맡고 있음

\- IoC를 적용하면 설계가 깔끔해지고 유연성 증가하며 확장성이 좋아짐

\- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재 필요

\- 스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼으며 IoC를 극한까지 적용하고 있는 프레임워크