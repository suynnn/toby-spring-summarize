## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

-   객체지향의 세계에서는 오브젝트에 대한 설계와 이를 구현한 코드가 변함
-   개발자가 객체를 설계할 때 가장 염두에 두어야 할 사항
    -   미래의 변화 대비
-   객체 지향 설계와 프로그래밍의 초기의 번거로운 작업 요구 이유
    -   변화에 효과적으로 대처 가능
    -   객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있음
-   미래의 변화에 가장 좋은 대책은?
    -   변화의 폭을 최소한으로 줄여주는 것
-   변경이 일어날 때 필요한 작업 최소화하고 다른 곳에 문제 일으키지 않게 할 수 있는 방법은?
    -   분리와 확장
-   모든 변경과 발전은 한 번에 한가지 관심사항에 집중해서 일어남
    -   결론 : 한 가지 관심이 한 군데에 집중되게 하자
    -   관심이 같은 것끼리 모으고 다른 것들은 떨어져 있게 하자

### 1.2.2 커넥션 만들기의 추출

#### UserDao의 관심사항

1.  DB 연결를 위한 커넥션을 어떻게 가져올까? 어떤 DB 쓰고, 어떤 드라이버 사용하고, 어떤 로그인 정보를 쓰는가? 등등 **DB 연결과 관련된 관심**
2.  **사용자 등록을 위한 DB에 보낼 SQL 문장을 담을 Statement 만들고 실행**. 파라미터로 넘어온 사용자 정보를 Statement에 바인딩, Statement에 담긴 SQL을 DB를 통해 실행
3.  **Statement와 Connection 오브젝트 닫기**

\+ 예외사항에 대한 처리 없음

가장 문제가 되는 사항

-   DB 커넥션 코드가 다른 관심사와 섞여 add()에 담김
-   위 코드가 get()에도 중복
    -   앞으로 수천 개의 dao를 만든다면 똑같이 수천 번 중복될 것

#### 중복 코드의 메소드 추출

가장 먼저 할 일 : 커넥션을 가져오는 중복된 코드 분리 -> getConnection() 이라는 이름의 독립적인 메소드 작성

```
Connection c = getConnection();

//

private static Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book"
        );
        return c;
}
```

-   드라이브 클래스와 URL이 바뀌었다거나 로그인 정보가 변경되어도 getConnection 코드만 수정하면 됨

결론 : 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 됨

#### 변경사항에 대한 검증 : 리팩토링과 테스트

앞에서 한 작업 : 여러 메서드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메서드로 분리해냄

-   기능 영향 X, 코드 구조만 변경 -> 이전보다 깔끔해졌고 미래의 변화에 좀 더 손쉽게 대응가능
-   이러한 작업을 리팩토링이라 함 
-   메서드 추출 : 공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것

> 리팩토링 : 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업  
> 중복된 코드는 매우 흔하게 발견되는 '나쁜 냄새' -> 적절한 리팩토링으로 제거
>
> 추천 책 : 리팩토링(마틴 파울러, 켄트 벡 공저)

### 1.2.3 DB 커넥션 만들기의 독립

현재의 문제점

-   이후 DB 커넥션을 가져오는 방법이 변경된다면..?

#### 상속을 통한 확장

방법

-   기존 UserDao 코드 한 단계 더 분리
    -   만들어둔 UserDao에서 메서드 구현 코드 제거하고 getConnection()을 추상 메서드로 만듦
    -   메서드 코드는 없지만 메소드 자체는 있어서 add(), get() 메서드에서 getConnection() 호출 코드는 그대로 유지
    -   서브 클래스에서는 userDao에서 선언했던 getConnection() 메서드를 원하는 방식대로 구현할수 있음

\=> 기존에는 같은 클래스에 다른 메서드로 분리됐던 DB 커넥션 연결이라는 관심을 이번에는 상속을 통해 서브클래스로 분리해버리는 것

UserDao.class

```
public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
```

NUserDao.class

```
public class NUserDao extends UserDao {

    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // N사 DB connection 생성코드
    }
}
```

-   DAO의 핵심 기능인 **어떻게 데이터 등록하고 가져올 것인가**(SQL 작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)라는 관심을 담당하는 UserDao와, **DB연결 방법은 어떻게 할 것인가**라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분됨
    -   새로운 DB 연결 방법 => UserDao를 상속을 통해 확장하기
-   디자인 패턴에서 **템플릿 메서드 패턴**
    -   슈퍼클래스에 기본적인 로직 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고 **그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 protected 메서드 등으로 만든 뒤 서브 클래스에서 이런 메서드를 필요에 맞게 구현**해서 사용하도록 하는 방법
-   팩토리 메서드 패턴
    -   UserDao의 getConnection() 메서드는 Connection 타입 오브젝트를 생성한다는 기능 정의한 추상 메서드
    -   UserDao의 서브클래스의 getConnection() 메서드는 어떤 Connection 클래스 오브젝트를 어떻게 생성할 것인지 결정하는 방법\=> **서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것**
-   getConnection() 메서드에서 생성하는 Connection 오브젝트의 구현 클래스는 제각각이겠지만 UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는 관심 안둠
-   UserDao는 어떤 기능을 사용하는 데에만 관심이 있고 NUserDao나 DUserDao에서는 어떤 식으로 Connection 기능을 제공하는지에 관심을 두고 있는 것
-   **UserDao는 Connection 오브젝트가 만들어지는 방법과 내부 동작방식에는 상관없이 자신이 필요한 기능을 Connection 인터페이스를 통해 사용하기만 할 뿐**

\=> **중요한 것 : 상속구조를 통해 성격이 다른 관심사항을 분리한 코드를 만들어내고, 서로 영향을 덜 주도록 했는지 이해하는 것**

> 디자인 패턴   
>
> 정의  
> \- 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션  
> 장점  
> \- 설계의 의도와 해결책을 함께 설명할 수 있다
>
> \- 객체지향 설계에 관한 것. 대부분 객체지향적 설계 원칙을 이용해 문제 해결  
> \- 객체 지향적 설계로부터 문제 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지 구조로 정리되기 때문에 패턴의 설계 구조를 보면 대부분 비슷  
>      - 클래스 상속  
>      - 오브젝트 합성
>
> 패턴에서 가장 중요한 것  
> \- 패턴의 핵심이 담긴 목적 또는 의도  
> \- 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지 기억해둬야 함
>
> 추천 책  
> \- GoF의 디자인 패턴(에릭 감마 외)  
> \- Head First Design Patterns(에릭 프리먼)

> 탬플릿 메소드 패턴
>
> 정의  
> \- 상속을 통해 슈퍼클래스 기능을 확장할 때 사용하는 가장 대표적인 방법
>
> \- 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 함  
> \- 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메서드를 훅(hook) 메서드라고 함

> 팩토리 메서드 패턴
>
> \- 상속을 통해 기능을 확장하게 하는 패턴
>
> 정의  
> \- 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메서드를 팩토리 메서드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법

-   위의 방법들은 상속을 사용했다는 단점이 있음
-   문제점들
    -   자바는 클래스의 다중상속을 허용하지 않아서 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 나중에 다른 목적으로 UserDao에 상속 적용하기는 힘듦
    -   상속을 통한 상하위 클래스 관계는 생각보다 밀접함 -> 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용함
    -   서브 클래스는 슈퍼클래스 기능을 직접 사용할 수 있으므로 슈퍼클래스 내부 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음
    -   DB 커넥션 생성하는 코드를 다른 DAO 클래스에 적용할 수 없음
        -   UserDao 클래스들이 계속 만들어진다면 getConnection() 구현코드가 매 DAO마다 중복돼서 나타나게 되어버림