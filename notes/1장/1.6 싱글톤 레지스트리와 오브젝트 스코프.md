## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> 오브젝트의 동일성과 동등성
>
> \- 동일성(identity) 비교 : 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트인지  
> \- 동등성(equality) 비교 : 동일한 정보를 담고 있는(equivalent) 오브젝트인지
>
> \- 두 개의 오브젝트가 동일하다면 사실 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐  
> \- 두 개의 오브젝트가 동일하진 않지만 동등한 경우에는 동등성 기준에 따라 두 오브젝트 정보가 동등하다고 판단하는 것

\- 스프링은 여러 번에 걸쳐 빈을 요청하더라도 **매번 동일한 오브젝트를 돌려줌**

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

\- 애플리케이션 컨텍스트 : 싱글톤을 저장하고 관리하는 _싱글톤 레지스트리Singleton registry_

#### 서버 애플리케이션과 싱글톤

\- 왜 스프링은 싱글톤으로 빈을 만드나? 스프링이 주로 적용되는 대상이 **자바 엔터프라이즈 기술 사용하는 서버환경**이기 때문 (스프링은 대부분 서버환경에서 사용됨)

\- 대규모 엔터프라이즈 서버 환경

-   서버 하나당 최대 초당 수십 ~ 수백 번의 요청 처리 필요
-   데이터 액세스 로직, 서비스 로직, 비즈니스 로직 등 다양한 기능 담당 오브젝트들이 참여하는 계층형 구조로 이뤄짐
-   비즈니스 로직 복잡한 경우 多
-   서비스 오브젝트라는 개념 일찍부터 사용
    -   서블릿 - 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트
    -   멀티스레드 환경에서 싱글톤으로 동작
    -   서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자 요청 담당 스레드들에서 하나의 오브젝트 공유해서 사용

\- 싱글톤 패턴 : 애플리케이션 안에 대개 **한 개의 오브젝트**만 만들어서 사용하는 것

-   하지만 사용하기 까다롭고 여러 문제점 존재

> 싱글톤 패턴
>
> \- 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴.  
> \- 애플리케이션 내에서 전역적으로 접근 가능  
> \- 단일 오브젝트만 존재해야 하고 이를 여러 곳에서 공유하는 경우에 주요 사용

#### 싱글톤 패턴의 한계

\- 싱글톤 구현 방법

-   클래스 밖에서 오브젝트 생성 못하도록 **생성자를 private**로
-   생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 static 필드 정의
-   static 팩토리 메서드인 getInstance() 만들고 이 메서드가 최초로 호출되는 시점에만 오브젝트가 만들어지게 함. 또는 스태틱 필드 초기값으로 미리 만들어둘 수 있음
-   한번 만들어진 후에는 getInstance()를 통해서 이미 만들어져 static 필드에 저장해둔 오브젝트 넘김

\- 싱글톤 패턴 구현 방식 문제점

-   **private 생성자를 갖고 있기 때문에 상속할 수 없다**
    -   private 생성자를 가진 클래스는 다른 생성자가 없다면 상속 불가
    -   객체지향 장점인 상속과 이를 이용한 다형성 적용 못함
-   **싱글톤은 테스트하기 어렵다**
    -   어렵거나 아예 테스트 불가능할 수 있음
    -   테스트는 엔터프라이즈 개발의 핵심인데 애플리케이션 코드를 싱글톤으로 만들면 테스트 만드는 데 지장이 있는 것이 큰 단점
-   **서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다**
    -   서버에서의 클래스 로더 구성 방식에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있음
    -   여러 개의 JVM에 분산돼서 설치 되는 경우에도 각각 독립적으로 오브젝트 생기므로 싱글톤으로서의 가치 ↓
-   **싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다**
    -   애플리케이션 어디서든지 사용됨
    -   아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태 갖는 것은 객체지향에서 권장안함

#### 싱글톤 레지스트리

\- 자바의 기본적인 싱글톤 패턴 구현 방식은 여러 단점이 있어서, **스프링이 직접 싱글톤 형태 오브젝트 만들고 관리**하는 기능 제공함 ← 싱글톤 레지스트리

\- 스프링 컨테이너는 싱글톤 생성, 관리, 공급하는 **싱글톤 관리 컨테이너**

\- 싱글톤 레지스트리 장점

-   스태틱 메서드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 **평범한 자바 클래스를 싱글톤으로 활용**하게 해줌
-   평범한 자바 클래스라도 IoC 방식 컨테이너 사용해서 생성, 관계설정, 사용 등에 대한 제어권을 컨테이너에 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있음 ← 오브젝트 생성의 모든 권한은 IoC 기능 제공하는 애플리케이션 컨텍스트에 있기 때문
-   객체지향 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약 없음

\- 결론 : 스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 싱글톤 만들고 관리해주는 싱글톤 레지스트리

### 1.6.2 싱글톤과 오브젝트 상태

\- 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우

-   **상태 정보를 내부에 갖고 있지 않은 무상태stateless 방식**으로 만들어져야 함

\- 다중 사용자 요청을 한번에 처리하는 스레드들이 싱글톤 오브젝트 인스턴스 변수 수정하는 것은 매우 위험

\- 결론 : 싱글톤은 기본적으로 인스턴스 필드 값 변경 및 유지하는 상태유지stateful 방식으로 만들지 않음

\- 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게?

-   파라미터와 로컬 변수, 리턴 값 이용
-   메서드 파라미터나 미서드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문

\- 스프링의 싱글톤 빈으로 사용되는 클래스를 만들 때는 기존의 UserDao처럼 개별적으로 바뀌는 정보는 **로컬 변수에 정의**하거나, **파라미터**로 주고받으면서 사용하게 해야함

\- ConnectionMaker는 읽기전용 정보이기 때문에 인스턴스 변수 사용해도 괜찮음. 그리고 DaoFactory에 @Bean 붙여서 만들었으니 스프링이 관리하는 빈이 될 것이고, 별다른 설정이 없다면 기본적으로 한 개만 만들어짐

\- 결론 : 자신이 사용하는 다른 싱글톤 빈 저장하려는 용도라면 인스턴스 변수 사용해도 좋음

### 1.6.3 스프링 빈의 스코프

\- 빈의 스코프scope : 스프링이 관리하는 오브젝트, 즉 빈이 생성되고 존재하고 적용되는 범위

\- 스프링 빈의 기본 스코프는 **싱글톤**

\- 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서 스프링 컨테이너가 존재하는 동안 계속 유지

\- 프로토타입 스코프 : 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트 만들어줌

\- 요청request 스코프 : 웹을 통해 새로운 HTTP 요청이 생길 때마다 생성

\- 세션session 스코프 : 웹의 세션과 스코프가 유사
